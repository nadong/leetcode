链表是一种物理存储单元上非连续，非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中的每一个元素成为结点）组成。结点可以在运行时动态生成。 每个结点包括两个部分： 一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性书序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度， 比另一个线性表顺序表快得多。 但是查找一个节点或者访问特定标号的节点需要0(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn) 和O(1).

pros:
不需要预先知道数据大小，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数据随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置的节点，但是不允许随机存取。链表有很多不同的类型： 单向链表， 双向链表

常见解题套路
1. 同时保有当前节点的指针，以及当前节点的前一个节点的指针
2. 快慢指针， fast 指针的移动速度是slow 指针的两倍，如果链表成环那么fast 和slow 必然会相遇。
3. 虚假的链表头，通过 new ListNode(0), 创建一个虚拟的头部。获取真正链表只需返回head.next(这在需要生成一个新链表的时候很有用)
4. 同时保有当前链表的尾部的指针，以及头部的节点指针。
5. 善用while 循环
6. 链表的头部和尾部是链表比较特殊的节点，需要注意区别对待。 


